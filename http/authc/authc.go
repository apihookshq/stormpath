// Copyright (c) 2012 Jason McVetta.  This is Free Software, released under the 
// terms of the GPL v3.  See http://www.gnu.org/copyleft/gpl.html for details.

// Package authc implements the Sauthc1 Stormpath cryptographic digest
// authentication algorithm.
package authc

// This code was inspired by the official Stormpath Ruby and Java SDKS:
//     https://github.com/stormpath/stormpath-sdk-ruby/blob/master/lib/stormpath-sdk/http/authc/sauthc1_signer.rb
//     https://github.com/stormpath/stormpath-sdk-java/blob/master/impl/src/main/java/com/stormpath/sdk/impl/http/authc/Sauthc1Signer.java

import (
	"crypto"
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"github.com/jmcvetta/guid"
	"github.com/jmcvetta/stormpath/http"
	"github.com/jmcvetta/stormpath/util"
	"math"
	"math/big"
	"sort"
	"strconv"
	"strings"
	"time"
)

// An ApiKey holds credentials for accessing an API.
type ApiKey struct {
	Id     string
	Secret string
}

// A Sauthc1Signer signs HTTP requests using the Sauthc1 algorithm.
type Sauthc1Signer struct {
	DefaultAlgorithm     crypto.Hash
	HostHeader           string
	AuthorizationHeader  string
	StorpathDateHeader   string
	IdTerminator         string
	Algorithm            string
	AuthenticationScheme string
	Sauthc1Id            string
	Sauthc1SignedHeaders string
	Sauthc1Signature     string
	DateFormat           string
	TimestampFormat      string
	Newline              string
	GuidGenerator        guid.Generator
}

// NewSigner returns a Sauthc1Signer object initialized with default values.
func NewSigner() Sauthc1Signer {
	s := Sauthc1Signer{
		DefaultAlgorithm:     crypto.SHA256,
		HostHeader:           "Host",
		AuthorizationHeader:  "Authorization",
		StorpathDateHeader:   "X-Stormpath-Date",
		IdTerminator:         "sauthc1_request",
		Algorithm:            "HMAC-SHA-256",
		AuthenticationScheme: "SAuthc1",
		Sauthc1Id:            "sauthc1Id",
		Sauthc1SignedHeaders: "sauthc1SignedHeaders",
		Sauthc1Signature:     "sauthc1Signature",
		DateFormat:           "%Y%m%d",
		TimestampFormat:      "%Y%m%dT%H%M%SZ",
		Newline:              "\n",
		GuidGenerator:        guid.SimpleGenerator(), // NOT configured for multi-instance snowflake GUIDs!
	}
	return s
}

// nonce returns concatenated string representations of a guid, generated by a
// snowflake algorithm, and a random integer.
//
// Note:  I have no fucking clue if this is a cryptographically secure nonce.  I
// think it might be, but you really shouldn't rely on that.
func (s *Sauthc1Signer) nonce() (string, error) {
	var result string
	// GUID
	i, err := s.GuidGenerator.NextId()
	if err != nil {
		return result, err
	}
	result = strconv.FormatInt(i, 10)
	// Random Int64
	b, err := rand.Int(rand.Reader, big.NewInt(math.MaxInt64))
	result += strconv.FormatInt(b.Int64(), 10)
	return result, nil // Success!
}

func (s *Sauthc1Signer) Sign(req *http.Request, key ApiKey) error {
	now := time.Now()
	timeStamp := now.Format(s.TimestampFormat)
	dateStamp := now.Format(s.DateFormat)
	nonce, err := s.nonce()
	if err != nil {
		return err
	}
	u, err := req.ResourceUri()
	if err != nil {
		return err
	}
	host := u.Host
	/*
			In the Ruby version of this algorithm, we see the following code to check
			default port and append append the port if unspecified.

		          host_header = uri.host
		          if !RequestUtils.default_port?(uri)

		            host_header << ":" << uri.port.to_s
		          end

			It appears this is required because Ruby's URI module splits host and port into
			seperate variables.  Go keeps them as a single string, so I do not think this
			will be necessary.
	*/
	req.Headers[s.HostHeader] = host
	req.Headers[s.StorpathDateHeader] = timeStamp
	canResPath := s.canonicalizeResourcePath(u.Path)
	canQs := s.canonicalizeQueryString(req)
	signedHeaders := s.getSignedHeaders(req)
	canHeaders := s.canonicalizeHeaders(req)
	// print( method, canResPath, canQs, sighedHeaders, dateStamp, nonce)
	payloadHash := hex.EncodeToString([]byte(s.hash(req.Body)))
	nl := s.Newline
	canReq := req.Method + nl +
		canResPath + nl +
		canQs + nl +
		canHeaders + nl +
		signedHeaders + nl +
		payloadHash
	canReqHash := s.hash(canReq)
	id := key.Id + "/" + dateStamp + "/" + nonce + "/" + s.IdTerminator
	stringToSign := s.Algorithm + nl +
		timeStamp + nl +
		id + nl +
		canReqHash
	// SAuthc1 uses a series of derived keys, formed by hashing different pieces of data
	kSecret := s.AuthenticationScheme + key.Secret

	return nil // Success!
}

// canonicalizeResourcePath returns the canonical form of a URI resource path.
func (s *Sauthc1Signer) canonicalizeResourcePath(path string) string {
	if path == "" {
		return "/"
	}
	return util.EncodeUrl(path, true, true)
}

func (s *Sauthc1Signer) canonicalizeQueryString(r *http.Request) string {
	return r.ToSQueryString(true)
}

// sortedHeaderKeys returns the keys of the Headers map, sorted in
// alphabetical order.
func (s *Sauthc1Signer) sortedHeaderKeys(r *http.Request) []string {
	// http://stackoverflow.com/a/2039180/164308
	keys := make([]string, len(r.QueryString))
	i := 0
	for k, _ := range r.QueryString {
		keys[i] = k
		i++
	}
	sort.Strings(keys)
	return keys
}

func (s *Sauthc1Signer) getSignedHeaders(r *http.Request) string {
	keys := s.sortedHeaderKeys(r)
	var result string
	for _, header := range keys {
		if result != "" {
			result += ";" + header
		} else {
			result += header
		}
	}
	return strings.ToLower(result)
}

func (s *Sauthc1Signer) hash(text string) []byte {
	h := sha256.New()
	h.Write([]byte(text))
	return h.Sum(nil)

}

func (s *Sauthc1Signer) canonicalizeHeaders(r *http.Request) string {
	var result string
	keys := s.sortedHeaderKeys(r)
	for _, header := range keys {
		result += strings.ToLower(header) + ":" + r.Headers[header]
		result += s.Newline
	}
	return result
}

func (s *Sauthc1Signer) sign(data, key string, algorithm crypto.Hash) string {
	hash := algorithm.New()
}
